// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: customers.sql

package db

import (
	"context"
)

const checkApiKeyExists = `-- name: CheckApiKeyExists :one
SELECT EXISTS(SELECT 1 FROM customers WHERE api_key = $1)
`

func (q *Queries) CheckApiKeyExists(ctx context.Context, apiKey string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkApiKeyExists, apiKey)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkPrefixExists = `-- name: CheckPrefixExists :one
SELECT EXISTS(SELECT 1 FROM customers WHERE prefix = $1)
`

func (q *Queries) CheckPrefixExists(ctx context.Context, prefix string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkPrefixExists, prefix)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUsernameExists = `-- name: CheckUsernameExists :one
SELECT EXISTS(SELECT 1 FROM customers WHERE username = $1)
`

func (q *Queries) CheckUsernameExists(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUsernameExists, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getCustomerByApiKey = `-- name: GetCustomerByApiKey :one
SELECT id, prefix, username, email, api_key, status, created_at, updated_at
FROM customers WHERE api_key = $1
`

func (q *Queries) GetCustomerByApiKey(ctx context.Context, apiKey string) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByApiKey, apiKey)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Prefix,
		&i.Username,
		&i.Email,
		&i.ApiKey,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomerByPrefix = `-- name: GetCustomerByPrefix :one
SELECT id, prefix, username, email, api_key, status, created_at, updated_at
FROM customers WHERE prefix = $1
`

func (q *Queries) GetCustomerByPrefix(ctx context.Context, prefix string) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByPrefix, prefix)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Prefix,
		&i.Username,
		&i.Email,
		&i.ApiKey,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomerByUsername = `-- name: GetCustomerByUsername :one
SELECT id, prefix, username, email, api_key, status, created_at, updated_at
FROM customers WHERE username = $1
`

func (q *Queries) GetCustomerByUsername(ctx context.Context, username string) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByUsername, username)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Prefix,
		&i.Username,
		&i.Email,
		&i.ApiKey,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertNewCustomer = `-- name: InsertNewCustomer :exec
INSERT INTO customers (prefix, username, email, api_key)
VALUES ($1, $2, $3, $4)
RETURNING id, prefix, username, email, api_key, status, created_at, updated_at
`

type InsertNewCustomerParams struct {
	Prefix   string
	Username string
	Email    string
	ApiKey   string
}

func (q *Queries) InsertNewCustomer(ctx context.Context, arg InsertNewCustomerParams) error {
	_, err := q.db.ExecContext(ctx, insertNewCustomer,
		arg.Prefix,
		arg.Username,
		arg.Email,
		arg.ApiKey,
	)
	return err
}

const updateCustomerStatusByUsername = `-- name: UpdateCustomerStatusByUsername :exec
UPDATE customers SET status = $1, updated_at=now() WHERE username = $2
RETURNING id, prefix, username, email, api_key, status, created_at, updated_at
`

type UpdateCustomerStatusByUsernameParams struct {
	Status   string
	Username string
}

func (q *Queries) UpdateCustomerStatusByUsername(ctx context.Context, arg UpdateCustomerStatusByUsernameParams) error {
	_, err := q.db.ExecContext(ctx, updateCustomerStatusByUsername, arg.Status, arg.Username)
	return err
}
